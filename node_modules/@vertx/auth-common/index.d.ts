/*
 * Copyright 2019 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

export abstract class AuthProvider {
  /**
   * Authenticate a user.
   *  <p>
   *  The first argument is a JSON object containing information for authenticating the user. What this actually contains
   *  depends on the specific implementation. In the case of a simple username/password based
   *  authentication it is likely to contain a JSON object with the following structure:
   *  <pre>
   *    {
   *      "username": "tim",
   *      "password": "mypassword"
   *    }
   *  </pre>
   *  For other types of authentication it contain different information - for example a JWT token or OAuth bearer token.
   *  <p>
   *  If the user is successfully authenticated a {@link User} object is passed to the handler in an {@link io.vertx.core.AsyncResult}.
   *  The user object can then be used for authorisation.
   * @param authInfo  The auth information
   * @param resultHandler  The result handler
   * 
   */
  authenticate(authInfo: { [key: string]: any }, resultHandler: ((res: AsyncResult<User>) => void) | Handler<AsyncResult<User>>) : void;
}

export abstract class ChainAuth extends AuthProvider {
  /**
   * Create a Chainable Auth Provider auth provider
   * @return the auth provider
   * 
   */
  static create() : ChainAuth;

  /**
   * Appends a auth provider to the chain.
   * @param other auth provider
   * @return self
   * 
   */
  append(other: AuthProvider) : ChainAuth;

  /**
   * Removes a provider from the chain.
   * @param other provider to remove
   * @return true if provider was removed, false if non existent in the chain.
   * 
   */
  remove(other: AuthProvider) : boolean;

  /**
   * Clears the chain.
   * 
   */
  clear() : void;
}

export abstract class HashingAlgorithm {
  /**
   * return the symbolic name for the algorithm
   * @return short id e.g.: sha512.
   * 
   */
  id() : string;

  /**
   * return the list of param names required for this algorithm.
   * @return set of param names.
   * 
   */
  params() : string[];

  /**
   * Should the encoded string use the default separator to split fields.
   * @return true by default.
   * 
   */
  needsSeparator() : boolean;
}

export abstract class HashingStrategy {
  /**
   * Factory method to load the algorithms from the system
   * @return a Hashing Strategy capable of hashing using the available algorithms
   * 
   */
  static load() : HashingStrategy;

  /**
   * Hashes a password.
   * @param id the algorithm id
   * @param params the algorithm specific paramters
   * @param salt the given salt
   * @param password the given password
   * @return the hashed string
   * 
   */
  hash(id: string, params: { [key: string]: string; }, salt: string, password: string) : string;

  /**
   * Time constant password check. Regardless of the check, this algorithm executes the same number of
   *  checks regardless of the correctly number of characters
   * @param hash the hash to verify
   * @param password the password to test against
   * @return boolean
   * 
   */
  verify(hash: string, password: string) : boolean;

  /**
   * Get an algorithm interface by its Id
   * @param id the algorithm id
   * @return the algorithm
   * 
   */
  get(id: string) : HashingAlgorithm;

  /**
   * Put or replace an algorithm into the list of system loaded algorithms.
   * @param id the algorithm id
   * @param algorithm the implementation
   * @return self
   * 
   */
  put(id: string, algorithm: HashingAlgorithm) : HashingStrategy;
}

export abstract class User {
  /**
   * Is the user authorised to
   * @param authority  the authority - what this really means is determined by the specific implementation. It might
   *                    represent a permission to access a resource e.g. `printers:printer34` or it might represent
   *                    authority to a role in a roles based model, e.g. `role:admin`.
   * @param resultHandler  handler that will be called with an {@link io.vertx.core.AsyncResult} containing the value
   *                        `true` if the they has the authority or `false` otherwise.
   * @return the User to enable fluent use
   * 
   */
  isAuthorized(authority: string, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : User;

  /**
   *
   * @deprecated See {@link #isAuthorized(String, Handler)}
   * 
   */
  isAuthorised(authority: string, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : User;

  /**
   * The User object will cache any authorities that it knows it has to avoid hitting the
   *  underlying auth provider each time.  Use this method if you want to clear this cache.
   * @return the User to enable fluent use
   * 
   */
  clearCache() : User;

  /**
   * Get the underlying principal for the User. What this actually returns depends on the implementation.
   *  For a simple user/password based auth, it's likely to contain a JSON object with the following structure:
   *  <pre>
   *    {
   *      "username", "tim"
   *    }
   *  </pre>
   * @return JSON representation of the Principal
   * 
   */
  principal() : { [key: string]: any };

  /**
   * Set the auth provider for the User. This is typically used to reattach a detached User with an AuthProvider, e.g.
   *  after it has been deserialized.
   * @param authProvider  the AuthProvider - this must be the same type of AuthProvider that originally created the User
   * 
   */
  setAuthProvider(authProvider: AuthProvider) : void;
}

import { Vertx } from '@vertx/core';

export abstract class VertxContextPRNG {
  /**
   * Get or create a secure non blocking random number generator using the current vert.x context. If there is no
   *  current context (i.e.: not running on the eventloop) then a {@link java.lang.IllegalStateException} is thrown.
   * @return A secure non blocking random number generator.
   * @throws IllegalStateException when there is no context available.
   * 
   */
  static current() : VertxContextPRNG;

  /**
   * Get or create a secure non blocking random number generator using the current vert.x instance. Since the context
   *  might be different this method will attempt to use the current context first if available and then fall back to
   *  create a new instance of the PRNG.
   * @param vertx a Vert.x instance.
   * @return A secure non blocking random number generator.
   * 
   */
  static current(vertx: Vertx) : VertxContextPRNG;

  /**
   * Returns a Base64 mime encoded String of random data with the given length. The length parameter refers to the length
   *  of the String before the encoding step.
   * @param length the desired string length before Base64 encoding.
   * @return A base 64 encoded string.
   * 
   */
  nextString(length: number) : string;

  /**
   * Returns a secure random int
   * @return random int.
   * 
   */
  nextInt() : number;

  /**
   * Returns a secure random int, between 0 (inclusive) and the specified bound (exclusive).
   * @param bound the upper bound (exclusive), which must be positive.
   * @return random int.
   * 
   */
  nextInt(bound: number) : number;
}
