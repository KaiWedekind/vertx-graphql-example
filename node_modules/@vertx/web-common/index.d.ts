/*
 * Copyright 2019 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

import { Buffer } from '@vertx/core';
import { WriteStream } from '@vertx/core';

export abstract class BodyCodec<T> {
  /**
   *
   * @return the UTF-8 string codec
   * 
   */
  static string() : BodyCodec<string>;

  /**
   * A codec for strings using a specific {@code encoding}.
   * @param encoding the encoding
   * @return the codec
   * 
   */
  static string(encoding: string) : BodyCodec<string>;

  /**
   *
   * @return the {@link Buffer} codec
   * 
   */
  static buffer() : BodyCodec<Buffer>;

  /**
   *
   * @return the {@link JsonObject} codec
   * 
   */
  static jsonObject() : BodyCodec<{ [key: string]: any }>;

  /**
   *
   * @return the {@link JsonArray} codec
   * 
   */
  static jsonArray() : BodyCodec<any[]>;

  /**
   * Create and return a codec for Java objects encoded using Jackson mapper.
   * @return a codec for mapping POJO to Json
   * 
   */
  static json<U>(type: any /* TODO: class */) : BodyCodec<U>;

  /**
   *
   * @return a codec that simply discards the response
   * 
   */
  static none() : BodyCodec<void>;

  /**
   * Create a codec that buffers the entire body and then apply the {@code decode} function and returns the result.
   * @param decode the decode function
   * @return the created codec
   * 
   */
  static create<T>(decode: (arg: Buffer) => T) : BodyCodec<T>;

  /**
   * A body codec that pipes the body to a write stream.
   * @param stream the destination tream
   * @return the body codec for a write stream
   * 
   */
  static pipe(stream: WriteStream<Buffer>) : BodyCodec<void>;
}

export abstract class FormDataPart {
  /**
   *
   * @return the name
   * 
   */
  name() : string;

  /**
   *
   * @return {@code true} when this part is an attribute
   * 
   */
  isAttribute() : boolean;

  /**
   *
   * @return {@code true} when this part is a file upload
   * 
   */
  isFileUpload() : boolean;

  /**
   *
   * @return the value when the part for a form attribute otherwise {@code null}
   * 
   */
  value() : string;

  /**
   *
   * @return the filename when this part is a file upload otherwise {@code null}
   * 
   */
  filename() : string;

  /**
   *
   * @return the pathname when this part is a file upload otherwise {@code null}
   * 
   */
  pathname() : string;

  /**
   *
   * @return the media type when this part is a file upload otherwise {@code null}
   * 
   */
  mediaType() : string;

  /**
   *
   * @return whether the file upload is text or binary when this part is a file upload otherwise {@code null}
   * 
   */
  isText() : boolean;
}

export abstract class MultipartForm {
  /**
   *
   * @return a multipart form instance
   * 
   */
  static create() : MultipartForm;

  /**
   * Add an attribute form data part.
   * @param name  the name of the attribute
   * @param value the value of the attribute
   * @return a reference to this, so the API can be used fluently
   * 
   */
  attribute(name: string, value: string) : MultipartForm;

  /**
   * Add a text file upload form data part.
   * @param name      name of the parameter
   * @param filename  filename of the file
   * @param pathname  the pathname of the file
   * @param mediaType the MIME type of the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textFileUpload(name: string, filename: string, pathname: string, mediaType: string) : MultipartForm;

  /**
   * Add a binary file upload form data part.
   * @param name      name of the parameter
   * @param filename  filename of the file
   * @param pathname  the pathname of the file
   * @param mediaType the MIME type of the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryFileUpload(name: string, filename: string, pathname: string, mediaType: string) : MultipartForm;
}

export abstract class TemplateEngine {
  /**
   * Render the template. Template engines that support partials/fragments should extract the template base path from
   *  the template filename up to the last file separator.
   * 
   *  Some engines support localization, for these engines, there is a predefined key "lang" to specify the language to
   *  be used in the localization, the format should follow the standard locale formats e.g.: "en-gb", "pt-br", "en".
   * @param context  the routing context
   * @param templateFileName  the template file name to use
   * @param handler  the handler that will be called with a result containing the buffer or a failure.
   * 
   */
  render(context: { [key: string]: any }, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;

  /**
   * Returns true if the template template caches template files. If false, then template files are freshly loaded each
   *  time they are used.
   * @return True if template files are cached; otherwise, false.
   * 
   */
  isCachingEnabled() : boolean;

  /**
   * Render the template. Template engines that support partials/fragments should extract the template base path from
   *  the template filename up to the last file separator.
   * 
   *  Some engines support localization, for these engines, there is a predefined key "lang" to specify the language to
   *  be used in the localization, the format should follow the standard locale formats e.g.: "en-gb", "pt-br", "en".
   * @param context  the routing context
   * @param templateFileName  the template file name to use
   * @param handler  the handler that will be called with a result containing the buffer or a failure.
   * 
   */
  render(context: { [key: string]: any; }, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;
}
